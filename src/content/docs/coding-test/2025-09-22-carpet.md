---
title: "카펫 (Lv.2)"
description: 카펫 문제 풀이.
date: 2025-09-22
tags: ["programmers", "Brute Force"]
draft: false
preferBodyH1: true
---

# 카펫 (Lv.2)

## 문제 요약

Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.

Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.

Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.

제한사항
갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.
카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.


## 풀이 코드 (C#)

```csharp
using System;

public class Solution {
    public int[] solution(int brown, int yellow) {
        int sum = brown + yellow;
        for (int i = sum - 3; i >= 3; i--)
        {
            if (sum % i != 0)
            {
                continue;
            }
            
            int width = i;
            int height = sum / i;
            if (width < height)
            {
                break;
            }
            
            int yellowWidth = width - 2;
            int yellowHeight = height - 2;
            if (yellowWidth * yellowHeight == yellow)
            {
                return new int[] {width, height};
            }
        }
        
        return new int[] {0,0};
    }
}
```

## 다른 사람 풀이

```csharp
// 문제가 개편되었습니다. 이로 인해 함수 구성이나 테스트케이스가 변경되어, 과거의 코드는 동작하지 않을 수 있습니다.
// 새로운 함수 구성을 적용하려면 [코드 초기화] 버튼을 누르세요. 단, [코드 초기화] 버튼을 누르면 작성 중인 코드는 사라집니다.
using System;

public class Solution {
    public int[] solution(int brown, int red) {
        int nSum = brown + red;
        int[] answer = new int[2];
        for (int i = 3; i < nSum / 3 + 1; i++)
            for (int j = i; j < nSum / 3 + 1; j++)
                if (i * j == nSum)
                {
                    if ((i - 2) * 2 + (j - 2) * 2 + 4 == brown)
                    {
                        answer[0] = j;
                        answer[1] = i;
                        return answer;
                    }
                }        
        return answer;
    }
}
```

## 개선된 코드

```csharp
using System;

public class Solution {
    public int[] solution(int brown, int yellow) {
        int sum = brown + yellow;

        for (int height = 3; height <= Math.Sqrt(sum); height++) {
            if (sum % height != 0) continue; // 약수만 확인
            int width = sum / height;

            if ((width - 2) * (height - 2) == yellow) {
                return new int[] { width, height };
            }
        }

        return new int[] {0, 0};
    }
}
```

- 약수 까지만 확인 하는 코드로도 충분히 많이 줄일 수 있음.


## 메모

- 선택 포인트: 갈색 격자가 테두리를 이루고, 노란색 격자가 내부에 채워진 카펫의 전체 크기(가로, 세로)를 구하는 완전 탐색 문제.
- 개선 가능: Math.Sqrt 메서드 사용으로 탐색 비용 줄이기 (약수는 이거로 충분 함)
- 주의할 부분: 없음

4. 학습 메모

- 패턴 정리:
  - 약수 탐색 문제 → √n까지만 확인하면 된다.
    - ✅ 약수는 항상 (a, b) 쌍으로 존재한다.
    - ✅ 작은 수는 √n 이하, 큰 수는 √n 이상에서 나온다.
    - ✅ 따라서 √n까지만 확인하면 모든 약수를 다 구할 수 있다.
  - 조건이 가로≥세로일 때는 (width, height) 순서를 정해주면 중복 제거 가능.
  - 완전 탐색 문제지만, 제약 조건을 잘 활용하면 효율적으로 줄일 수 있다.
- 복습 포인트:
  - 약수 탐색 최적화 (√n) 패턴 다시 한번 복습.
  - 가로·세로 문제에서 "조건(가로 ≥ 세로)"을 어떻게 루프에 녹여 넣는지 연습.