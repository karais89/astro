---
title: "의상 (Lv.2)"
description: 의상 문제 풀이.
date: 2025-09-20
tags: ["programmers"]
draft: false
preferBodyH1: true
---

# 의상 (Lv.2)

## 문제 요약

코니는 매일 다른 옷을 조합하여 입는것을 좋아합니다.

예를 들어 코니가 가진 옷이 아래와 같고, 오늘 코니가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야합니다.

종류 이름
얼굴 동그란 안경, 검정 선글라스
상의 파란색 티셔츠
하의 청바지
겉옷 긴 코트

- 코니는 각 종류별로 최대 1가지 의상만 착용할 수 있습니다. 예를 들어 위 예시의 경우 동그란 안경과 검정 선글라스를 동시에 착용할 수는 없습니다.
- 착용한 의상의 일부가 겹치더라도, 다른 의상이 겹치지 않거나, 혹은 의상을 추가로 더 착용한 경우에는 서로 다른 방법으로 옷을 착용한 것으로 계산합니다.
- 코니는 하루에 최소 한 개의 의상은 입습니다.
코니가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.

## 풀이 코드 (C#)

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int solution(string[,] clothes) {
        // 종류, 개수
        Dictionary<string, int> clothesDic = new Dictionary<string, int>();
        for (int i = 0; i < clothes.GetLength(0); i++)
        {
            var clothesName = clothes[i, 0];
            var clothesType = clothes[i, 1];
            
            if (clothesDic.ContainsKey(clothesType))
            {
                clothesDic[clothesType]++;
            }
            else
            {
                clothesDic[clothesType] = 1;
            }
        }
        
        int answer = 1;        
        foreach (var cloth in clothesDic)
        {
            Console.WriteLine($"{cloth.Key} {cloth.Value}");
            answer *= (cloth.Value + 1);
        }
        
        return answer - 1;
    }
}
```

## 다른 사람 풀이

```csharp
using System;
using System.Linq;

public class Solution {
    public int solution(string[,] clothes) {
        return Enumerable.Range(0, clothes.GetLength(0)).Select(i => clothes[i,1]).GroupBy(p => p).Select(g => g.Count() + 1).Aggregate(1, (p, q) => p * q) - 1;
    }
}
```

- Linq 사용하면 한줄로 해결이 가능하다 ~어쨌든 한줄~
- 가독성은 딱히 좋다고 하긴 힘들지 않을까 싶음

## 개선된 코드 (가독성 우선, linq 남용 x)

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int solution(string[,] clothes) {
        var counts = new Dictionary<string, int>();

        for (int i = 0; i < clothes.GetLength(0); i++) {
            string type = clothes[i, 1];
            // if (!counts.TryAdd(type, 1)) counts[type]++; or
            counts[type] = counts.GetValueOrDefault(type, 0) + 1;
        }

        long product = 1;
        foreach (var kv in counts)
            product *= (kv.Value + 1);

        return (int)(product - 1);
    }
}
```

- 의도: “종류별 개수를 세고, (개수+1) 곱에서 아무것도 안 입는 1 빼기”가 한 눈에 들어옴.
- TryAdd 혹은 GetValueOrDefault 사용
- TryAdd는 딕셔너리에 키가 없으면 (키, 값)을 추가하고 true를, 이미 있으면 아무 것도 안 하고 false를 반환하는 메서드예요.

## 메모

- 선택 포인트: 종류별로 “입지 않음”을 포함한 선택 수를 곱한 뒤(∏(개수+1)) 아무 것도 안 입는 경우 1을 빼면 된다.
- 개선 가능: 가독성 부분 개선
- 주의할 부분: 입지 않는 경우, 전부 입지 않은 경우에 대한 처리 진행

## 학습 메모 (패턴·알고리즘 정리 & 복습 포인트)

- 패턴: 분류 후 곱의 법칙(Multiplication Rule) → 각 범주별 선택지에 “선택 안 함”을 추가하고 전부 곱한 뒤, 공집합 제거.
- 핵심 공식: answer = ∏(count(type) + 1) - 1
- 자주 하는 실수
  - 1 잊기(아무 것도 안 입는 경우 제외).
  - 배열 인덱스 실수(이름/종류 위치 혼동).
  - 오버플로 가능성 무시(안전하게 long 곱셈 습관).
- 복습 포인트
  - 해시맵 빈도 카운팅 패턴(try-add/증분) 손에 익히기.
  - LINQ GroupBy → Select → Aggregate 흐름을 작은 단계로 나눠 읽기 좋게 쓰는 법.
  - 응용: “종류별 0~1개 선택” 조합 문제 전반(액세서리, 스티커, 파츠 조립 등)에 동일 공식을 적용해보기.
