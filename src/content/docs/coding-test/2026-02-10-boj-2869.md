---
title: "BOJ 2869 달팽이는 올라간다"
description: 수학적 계산으로 달팽이가 목표 높이에 도달하는 날짜를 구하는 문제 풀이.
date: 2026-02-10
tags: ["boj", "bronze", "math"]
draft: false
preferBodyH1: true
---

# BOJ 2869 달팽이는 올라간다

## 문제 요약

달팽이가 높이 V인 나무에 올라간다. 낮 동안 A만큼 올라가고, 밤에 B만큼 떨어진다. 달팽이가 낮 동안 V 이상에 도달하면 그 날로 올라간 것으로 간주한다. 며칠이 걸리는가?

제약:
- 1 ≤ B < A ≤ V ≤ 1,000,000,000

예시: A=3, B=2, V=10
- 1일차: 3 올라감 (3) → 밤에 2 떨어짐 (1)
- 2일차: 3 올라감 (4) → 밤에 2 떨어짐 (2)
- 3일차: 3 올라감 (5) → 밤에 2 떨어짐 (3)
- ...
- 9일차: 3 올라감 (9) → 밤에 2 떨어짐 (7)
- 10일차: 3 올라감 (10) → **목표 달성!** → 답: 10일

## 접근

**핵심 아이디어:**
- 마지막 날은 특별함. 마지막 날에 낮에 A만큼 올라가면 V에 도달하므로, 밤의 떨어짐(B)은 관계없음.
- 따라서 마지막 날 이전까지는 매일 (A - B)씩만 올라감.
- 마지막 날 **직전**에 최소 (V - A) 높이에 있어야 함.
  - 그 높이에서 +A = V 이상이 되기 때문
- 필요한 일수 = ⌈(V - A) / (A - B)⌉ + 1
  - `(V - A) / (A - B)`를 올림 → 마지막 날 전까지의 일수
  - + 1 → 마지막 날 추가

**올림 나눗셈 (정수):**
정수 올림: `⌈x / y⌉ = (x + y - 1) / y` (양의 정수)

## 풀이 코드 (C#)

```csharp
var nums = Array.ConvertAll(Console.ReadLine()!.Split(), int.Parse);
(int climb, int slip, int height) = (nums[0], nums[1], nums[2]);

int dailyProgress = climb - slip;
int heightBeforeFinalDay = height - climb;

int daysBeforeFinal = heightBeforeFinalDay / dailyProgress;
bool hasRemainder = heightBeforeFinalDay % dailyProgress != 0;
int extraDay = hasRemainder ? 1 : 0;

int totalDays = daysBeforeFinal + extraDay + 1;
Console.WriteLine(totalDays);
```

**로직 설명:**
1. `climb` = A (낮 진도), `slip` = B (밤 후퇴), `height` = V (목표 높이)
2. `dailyProgress` = A - B (마지막 날 전 하루 순 진도)
3. `heightBeforeFinalDay` = V - A (마지막 날 직전 필요 높이)
4. `daysBeforeFinal` = 정수 나눗셈 결과
5. `hasRemainder` = 나머지가 있으면 1일 추가
6. `totalDays` = daysBeforeFinal + extraDay + 1

## 메모

- 브루트포스 (시뮬레이션)로는 V가 최대 10억이므로 시간초과 불가피.
- 수학적 공식으로 **O(1) 해결**.
- 마지막 날의 특수성을 놓치면 안 되는 문제.

## 학습 메모

- **핵심 패턴:** 마지막 항(또는 경계)이 다른 규칙을 따르는 경우, 그 전부터 따로 계산 후 마지막 항 1개 추가.
- **올림 나눗셈:** `(x + y - 1) / y` 패턴 암기하면 주말 관련 문제에서 유용.
- **복습 포인트:**
  - 문제에서 "~이상에 도달하면" 같은 경계조건 주의
  - 간단해 보이는 시뮬레이션 문제라도 제약(V ≤ 10억)은 수학적 해법이 필수인지 먼저 체크
