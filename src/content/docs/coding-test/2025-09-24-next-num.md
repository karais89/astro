---
title: "다음 큰 숫자 (Lv.2)"
description: 다음 큰 숫자 문제 풀이.
date: 2025-09-24"
tags: ["programmers"]
draft: false
preferBodyH1: true
---

# 다음 큰 숫자 (Lv.2)

## 문제 요약

자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.

조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다.
조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다.
조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.
예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.

자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.


## 풀이 코드 (C#)

```csharp
using System;

class Solution 
{
    private int ToBinaryOneCount(int n)
    {
        if (n == 0) return 0;
        
        int count = 0;
        int newN = n;
        while (newN > 0)
        {
            bool isOne = newN % 2 != 0;
            if (isOne)
            {
                count++;
            }
            newN /= 2;
        }
        
        return count;
    }
    
    public int solution(int n) 
   {
        int count = ToBinaryOneCount(n);
        int answer = n;
        while (true)
        {
            answer++;
            if (count == ToBinaryOneCount(answer))
            {
                break;
            }
        }

        return answer;
    }
}
```

- 코드 풀이 이후 효율성 테스트에서 실패한 코드.


## 다른 사람 풀이

```csharp
using System;
using System.Text.RegularExpressions;

class Solution 
{
    public int solution(int n) 
   {
        int answer = 0;
        int t = Regex.Matches(Convert.ToString(n,2), "1").Count;
        while(true) {   
            if( t == Regex.Matches(Convert.ToString(++n,2), "1").Count )
                break;
        }

        return n;
    }
}
```

- 좋아요를 가장 많이 받은 풀이긴 하나.
- 직관적이지만, 문자열 변환 + 정규식 매칭이라 가장 비효율적.
- 효율성 테스트에서 더 빠르게 실패할 가능성이 큼.

## 개선 코드

### 문자열 기반 비트 조작 풀이 (C#)
```csharp
using System;
using System.Linq;

class Solution 
{
    public int solution(int n) 
    {
        // 1. 2진수 문자열 변환 (앞에 0을 붙여 overflow 방지)
        string bits = "0" + Convert.ToString(n, 2);
        char[] arr = bits.ToCharArray();

        // 2. 뒤에서부터 "01" 찾기
        int idx = bits.LastIndexOf("01");

        // 3. "01" → "10"으로 바꾸기
        arr[idx] = '1';
        arr[idx + 1] = '0';

        // 4. idx 이후 부분 잘라내기
        string left = new string(arr, 0, idx + 2);
        string right = new string(arr, idx + 2, arr.Length - (idx + 2));

        // 5. 오른쪽 부분에 있는 1 개수를 센 뒤,
        int ones = right.Count(c => c == '1');
        int zeros = right.Length - ones;

        // 6. "000..111.." 형태로 재배치
        right = new string('0', zeros) + new string('1', ones);

        // 7. 합쳐서 10진수 변환
        string resultBits = left + right;
        return Convert.ToInt32(resultBits, 2);
    }
}
```

- 뒤에서부터 제일 먼저 나오는 01을 10으로 바꾸고, 그 뒤를 000...111...로 정리하면 된다.

### 비트 연산 버전 (효율성 위주)

```csharp
using System;

class Solution 
{
    public int solution(int n) 
    {
        int c = n;
        int c0 = 0; // 끝 0 개수
        int c1 = 0; // 끝 1 개수

        // Step 1: 끝 0 세기
        while (((c & 1) == 0) && (c != 0))
        {
            c0++;
            c >>= 1;
        }

        // Step 2: 끝 1 세기
        while ((c & 1) == 1)
        {
            c1++;
            c >>= 1;
        }

        // p = 바꿔야 하는 위치
        int p = c0 + c1;

        // Step 3: p번째 비트를 1로
        n |= (1 << p);

        // Step 4: p 이하 비트를 전부 0으로
        n &= ~((1 << p) - 1);

        // Step 5: (c1-1)개의 1을 맨 오른쪽에 배치
        n |= (1 << (c1 - 1)) - 1;

        return n;
    }
}
```

- 가장 효율적인 알고리즘으로 보이나, 다소 난해 할 수 있음.
- 오른쪽에서 제일 먼저 나오는 01을 10으로 바꾸고, 그 뒤의 비트들을 가장 작은 수가 되도록 정리한다.

## 메모

- 선택 포인트: 10진수를 2진수로 변형 후 1의 숫자 세보기로 접근해봄.
- 개선 가능: 효율성 테스트 실패함 다른 방법 모색
- 주의할 부분: 순서대로 숫자를 검사할때 효율성 테스트 실패하게 됨.

## 학습 메모

- 이 풀이의 본질은 “다음 순열(next permutation)” 알고리즘.
- 비트 매직 버전은 효율성 최강, 문자열 버전은 가독성 최강.
- 상황에 따라 선택 가능:
  - 코테 → 비트 연산 버전
  - 학습/블로그 정리 → 문자열 버전