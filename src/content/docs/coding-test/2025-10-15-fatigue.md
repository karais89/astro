---
title: "피로도 (Lv.2)"
description: 피로도 문제 풀이.
date: 2025-10-15"
tags: ["programmers", "DFS"]
draft: false
preferBodyH1: true
related:
  - slug: "blog/2025-09-23-dfs-bfs"
---

# 피로도 (Lv.2)

## 문제 요약

### 문제 설명

XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 일정 피로도를 사용해서 던전을 탐험할 수 있습니다. 이때, 각 던전마다 탐험을 시작하기 위해 필요한 "최소 필요 피로도"와 던전 탐험을 마쳤을 때 소모되는 "소모 피로도"가 있습니다. "최소 필요 피로도"는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, "소모 피로도"는 던전을 탐험한 후 소모되는 피로도를 나타냅니다. 예를 들어 "최소 필요 피로도"가 80, "소모 피로도"가 20인 던전을 탐험하기 위해서는 유저의 현재 남은 피로도는 80 이상 이어야 하며, 던전을 탐험한 후에는 피로도 20이 소모됩니다.

이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다. 유저의 현재 피로도 k와 각 던전별 "최소 필요 피로도", "소모 피로도"가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때, 유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항

k는 1 이상 5,000 이하인 자연수입니다.
dungeons의 세로(행) 길이(즉, 던전의 개수)는 1 이상 8 이하입니다.
dungeons의 가로(열) 길이는 2 입니다.
dungeons의 각 행은 각 던전의 ["최소 필요 피로도", "소모 피로도"] 입니다.
"최소 필요 피로도"는 항상 "소모 피로도"보다 크거나 같습니다.
"최소 필요 피로도"와 "소모 피로도"는 1 이상 1,000 이하인 자연수입니다.
서로 다른 던전의 ["최소 필요 피로도", "소모 피로도"]가 서로 같을 수 있습니다.

## 풀이 코드 (C#)

```csharp
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class Solution {
    int maxCount = 0;
    public int solution(int k, int[,] dungeons) {
        bool[] isVisited = new bool[dungeons.GetLength(0)];

        Search(k, dungeons, isVisited, 0);

        return maxCount;
    }

    void Search(int point, int[,] dungeons, bool[] isVisited, int count)
    {
        maxCount = Math.Max(maxCount, count);

        for (int i = 0; i < dungeons.GetLength(0); i++)
        {
            int need = dungeons[i, 0];
            int cost = dungeons[i, 1];

            // 아직 방문하지 않고, 피로도 충분한 던전이면
            if (!isVisited[i] && point >= need)
            {
                isVisited[i] = true;
                Search(point - cost, dungeons, isVisited, count + 1);
                isVisited[i] = false;
            }
        }
    }
}
```

1. 현재 상태 기록: maxCount를 갱신해 현재까지 탐험한 던전 개수를 기록합니다.
2. 모든 던전 순회: 아직 방문하지 않은 던전 중 현재 피로도로 가능한 던전을 찾습니다.
3. 재귀 호출: 탐험 후 point - cost 만큼 피로도를 줄이고 count + 1로 다음 탐색을 진행합니다.
4. 백트래킹: 재귀가 끝나면 isVisited[i]를 다시 false로 돌려 다른 경로 탐색을 허용합니다.

“현재 경로에서 갈 수 있는 모든 던전을 시도하고, 돌아와서 다른 경로를 시도하는 반복 구조”

## 다른 사람의 풀이

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Solution {
    List<int> list = new List<int>();
    public int solution(int k, int[,] dungeons) {
        bool[] check = new bool[dungeons.GetLength(0)];
        DFS(k, 0, check, dungeons);
        return list.Max();
    }

    private void DFS(int k, int count, bool[] check, int[,] dungeons){
        for(int i=0; i<dungeons.GetLength(0); i++){
            int countNew = count;
            if(check[i]==false){
                if(k>=dungeons[i,0]){
                    bool[] checkNew = (bool[])check.Clone();
                    countNew++;
                    checkNew[i] = true;
                    list.Add(countNew);
                    DFS(k-dungeons[i,1] ,countNew, checkNew, dungeons);
                }   
            }
        }
    }           
}
```

## 메모

이 문제는 완전탐색(Brute Force) 문제이며, 던전을 탐험할 수 있는 모든 순서의 경우의 수를 시도해야 한다.
탐색 방법으로는 DFS(깊이 우선 탐색) 이 적합하며, 한 경로의 탐색이 끝나면 다시 돌아가는 백트래킹 구조로 구현한다.
visited 배열을 사용해 중복 탐색을 방지하고, 재귀 종료 시점마다 최대 탐험 개수를 갱신한다.

## 학습 메모

- 완전탐색(Brute Force) + DFS + 백트래킹
- 모든 가능한 순서를 시도하는 문제는 “순열(permutation)” 형태로 생각
- visited 배열은 백트래킹의 핵심 도구