---
title: "올바른 괄호 (Lv.2)"
description: 올바른 괄호 문제 풀이.
date: 2025-09-18
tags: ["programmers", "stack", "queue"]
draft: false
preferBodyH1: true
---

# 올바른 괄호 (Lv.2)

## 문제 요약

괄호가 바르게 짝지어졌다는 것은 '(' 문자로 열렸으면 반드시 짝지어서 ')' 문자로 닫혀야 한다는 뜻입니다. 예를 들어

"()()" 또는 "(())()" 는 올바른 괄호입니다.
")()(" 또는 "(()(" 는 올바르지 않은 괄호입니다.
'(' 또는 ')' 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.

## 풀이 코드 (C#)

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public bool solution(string s) {
        bool answer = true;
        
        Console.WriteLine(s);
        // stack/queue 문제? stack/queue를 사용 해야 하나?
        Stack<char> stackChars = new Stack<char>();
        foreach (char c in s)
        {
            if (c == '(' || c == ')')
            {
                stackChars.Push(c);        
            }
        }
        
        if (stackChars.Count % 2 != 0)
        {
            return false;
        }
        
        int closeBrackets = 0;
        while (stackChars.Count > 0)
        {
            char c = stackChars.Pop();
            if (c == ')')
            {
                closeBrackets++;
            }
            else
            {
                closeBrackets--;
            }
            
            if (closeBrackets < 0)
            {
                answer = false;
                break;
            }        
        }
        
        return answer;
    }
}
```

## 다른 사람 풀이

```csharp
using System;

public class Solution {
            public bool solution(string s)
            {
            int length = s.Length/2;

            for(int i=0; i< length; i++)
            {
                s = s.Replace("()", "");
            }

            return s.Length >= 1 ? false : true;
            }
}
```

- 이런식으로도 해결 가능하다? 정도의 해답 아닐까 싶음.

## 개선안

```csharp
public class Solution {
    public bool solution(string s) {
        int balance = 0;
        foreach (char c in s) {
            if (c == '(') balance++;
            else balance--;
            
            if (balance < 0) return false; // ')'가 먼저 나오면 바로 실패
        }
        return balance == 0;
    }
}
```

- 모든 문자를 스택에 담은 뒤에 pop하면서 확인하는 방식 → 괄호 검증 시 굳이 전체를 담을 필요 없음.
- stackChars.Count % 2 != 0 같은 체크는 불필요. 짝수여도 잘못된 경우가 많기 때문.
- closeBrackets 변수를 감소/증가시키는 방식은 사실상 왼쪽 괄호 카운트 방식과 유사하므로, 굳이 스택이 필요하지 않음.

## 메모

- 선택 포인트: stack으로 push/pop 하면서 괄호 매칭 확인
- 개선 가능: 사실 단일 괄호는 stack 대신 balance로 단순화 가능
- 주의할 부분: 중간에 스택이 비어있을 때 pop 하면 에러 → 방어 처리 필요

## 학습 메모 (패턴·알고리즘 정리, 복습 포인트)

- 패턴: 괄호 문제는 전형적인 스택/카운팅 패턴.
  - 여는 괄호 → push (혹은 balance++), 닫는 괄호 → pop (혹은 balance--).
  - 중간에 음수가 되면 실패, 마지막 balance가 0이어야 성공.
- 복습 포인트:
  - 문자열 검증 문제에서 스택 vs 카운터 단순화 차이를 항상 고민하기.
  - replace 반복 풀이처럼 브루트포스 접근은 직관적이지만 효율성을 따져봐야 함.
- 추천 문제 유형:
  - 괄호의 최대 깊이 (balance 활용)
  - 중괄호/대괄호/여러 타입 괄호 매칭 문제 (스택 필요)
  - 파서/컴파일러 괄호 검사기 구현
