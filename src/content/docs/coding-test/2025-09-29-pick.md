---
title: "귤 고르기 (Lv.2)"
description: 귤 고르기 문제 풀이.
date: 2025-09-29"
tags: ["programmers", "Greedy"]
draft: false
preferBodyH1: true
---

# 귤 고르기 (Lv.2)

## 문제 요약

경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 'k'개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.

예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.

경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

## 풀이 코드 (C#)

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Solution {
    public int solution(int k, int[] tangerine) {

        Dictionary<int, int> tangerineDic = new Dictionary<int, int>();
        for (int i = 0; i < tangerine.Length; i++)
        {
            int val = tangerine[i];
            if (tangerineDic.TryGetValue(val, out int result))
            {
                tangerineDic[val]++;
            }
            else
            {
                tangerineDic[val] = 1;
            }
        }
        
        var maxSortingList = tangerineDic.Values.ToList().OrderByDescending(i => i);
        
        // sorting한 값 더해서 카운팅 하면 됨
        int answer = 0;
        int sum = 0;
        foreach (var v in maxSortingList)
        {
            sum += v;
            answer++;
            if (sum >= k)
            {
                return answer;
            }
        }
        
        
        return answer;
    }
}
```

## 다른 사람의 풀이
```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int solution(int k, int[] tangerine) {
        int answer = 0;
        Dictionary<int, int> size = new Dictionary<int, int>();
        foreach(int t in tangerine)
        {
            if(!size.TryAdd(t, 1))
            {
                size[t]+=1;
            }
        }
        List<int> count = new List<int>(size.Values);
        count.Sort();
        int kCount = 0;
        int kIndex = count.Count-1;
        while(k>kCount)
        {
            kCount+=count[kIndex--];
            answer++;
        }
        return answer;
    }
}
```

- 내 풀이와 다른 점? TryAdd 사용한 부분? 요 부분은 나는 가독성 때문에 오히려 별로라고 생각 함.
- sorting을 내림 차순으로 하고 뒤에서부터 비교한 부분? 요것도 음.. 미지수

### 리팩토링 코드

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int solution(int k, int[] tangerine) {
        var counts = new Dictionary<int, int>();
        
        // 빈도수 집계
        foreach (var size in tangerine) {
            counts[size] = counts.GetValueOrDefault(size) + 1;
        }

        // 빈도수를 내림차순 정렬
        var freqList = new List<int>(counts.Values);
        freqList.Sort((a, b) => b.CompareTo(a));

        // 큰 수부터 더해가며 k개 채우기
        int sum = 0, answer = 0;
        foreach (var count in freqList) {
            sum += count;
            answer++;
            if (sum >= k) break;
        }

        return answer;
    }
}
```

**개선 포인트**
1. Dictionary 채우기
  - GetValueOrDefault 사용으로 if/else 제거 → 한 줄로 빈도수 증가.
2. 정렬 방식
  - List<int>로 변환 후 Sort 메서드에 비교자 전달 → 성능·가독성 모두 안정적.
3. 불필요한 변수 제거
  - maxSortingList 대신 바로 freqList로 처리.
  - return answer 조건을 break로 정리해 더 직관적으로 작성.

## 메모

- 선택 포인트: 가장 적은 종류를 반환? 큰 수부터 세면서 넣어주기 라고 판단.
- 개선 가능: linq 부분을 유지하는 것이 더 좋은 방법일지? 가독성을 증가시킬 수 있는 방법은 없을지 고민 필요.
- 주의할 부분: 없음

### 학습 메모

- 핵심 패턴: Greedy + 빈도 정렬
  - 필요한 개수(k)를 채우는 데 가장 효율적인 방법은 많이 있는 크기부터 선택하는 것.
- C# 팁
  - Dictionary 채우기: GetValueOrDefault, TryAdd → 상황에 맞게 가독성/성능 고려.
  - 정렬: List.Sort가 OrderByDescending보다 성능상 간단하나, LINQ는 읽기 쉬움.
- 복습 포인트
  - 이 문제는 "종류 최소화" 문제이지만, 본질은 "빈도수가 높은 원소부터 채워넣기" → 그리디 전형.
  - 유사 유형: 폰켓몬, 의상, 베스트 앨범 등 "종류 vs 개수 최적화" 문제.