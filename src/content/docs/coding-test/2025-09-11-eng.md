---
title: "영어 끝말잇기 (Lv.2)"
description: 영어 끝말잇기 문제 풀이.
date: 2025-09-11
tags: ["programmers"]
draft: false
preferBodyH1: true
---

# 영어 끝말잇기 (Lv.2)

## 문제 요약

1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.

1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.
마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.
앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.
이전에 등장했던 단어는 사용할 수 없습니다.
한 글자인 단어는 인정되지 않습니다.
다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.

tank → kick → know → wheel → land → dream → mother → robot → tank

위 끝말잇기는 다음과 같이 진행됩니다.

1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.
2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.
3번 사람이 자신의 첫 번째 차례에 know를 말합니다.
1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.
(계속 진행)
끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는 단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.

사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.

## 풀이 코드 (C#)

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

class Solution
{
    public int[] solution(int n, string[] words)
    {   
        HashSet<string> duCheckSet = new HashSet<string>();
        string prevWord = "";
        int wrongIndex = -1;
        for (int i = 0; i < words.Length; i++)
        {
            string word = words[i];
            if (duCheckSet.Contains(word))
            {
                wrongIndex = i;
                System.Console.WriteLine($"duplicate word {duCheckSet.Count}");
                break;
            }
            
            if (string.IsNullOrEmpty(prevWord))
            {
                prevWord = word;
                duCheckSet.Add(word);
                continue;
            }
            
            var lastWord = prevWord.LastOrDefault();
            var firstWord = word.FirstOrDefault();            
            if (lastWord != firstWord)
            {
                wrongIndex = i;
                System.Console.WriteLine($"wrong word {prevWord} -> {word}");
                break;
            }
            
            prevWord = word;
            duCheckSet.Add(word);
        }
        
        if (wrongIndex != -1)
        {
            int n1 = wrongIndex % n; // 번호
            int n2 = wrongIndex / n; // 차례
            return new int[] { n1 + 1, n2 + 1 };
        }
        
        return new int[] {0, 0};    
    }
}
```

## 다른 사람 풀이
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
class Solution
{
    public int[] solution(int n, string[] words)
    {
        List<string> wordList = new List<string>();
        int index = 0;
        foreach(var v in words)
        {
            if(wordList.Count != 0)
            {
                if(v.Length == 1 || wordList.Contains(v) || wordList[index - 1].Last() != v.First())
                {
                    return new int[] {index % n + 1, index / n + 1};
                }
            }

            wordList.Add(words[index]);
            index++;
        }

        // [실행] 버튼을 누르면 출력 값을 볼 수 있습니다. 
        System.Console.WriteLine("Hello C#");

        return new int[] {0, 0};
    }
}
```

## 읽기 좋은 코드로 리팩토링
```csharp
using System.Collections.Generic;

public class Solution
{
    public int[] solution(int n, string[] words)
    {
        var seen = new HashSet<string>();
        int[] FailAt(int i) => new int[] { i % n + 1, i / n + 1 };

        // 첫 단어 등록
        if (words.Length > 0)
        {
            if (words[0].Length == 1) return FailAt(0);
            seen.Add(words[0]);
        }

        for (int i = 1; i < words.Length; i++)
        {
            string prev = words[i - 1];
            string cur  = words[i];

            // 1) 한 글자 금지
            if (cur.Length == 1) return FailAt(i);

            // 2) 중복 금지
            if (!seen.Add(cur)) return FailAt(i);

            // 3) 연결 규칙
            char prevLast = prev[^1];
            char curFirst = cur[0];
            if (prevLast != curFirst) return FailAt(i);
        }

        return new int[] { 0, 0 };
    }
}
```
- 조기 리턴 및 함수화로 인해 확실히 이 쪽이 더 가독성이 좋음.
- 조기 리턴의 경우 항상 사용하는 부분이긴 하지만 코딩 테스트 시에는 문제 풀기에 급급한 느낌이라 사용하지 않았는데, 조금 더 의도적으로 생각하면서 작업하면 좋을듯.

## 메모
- 핵심 아이디어: 끝말잇기 게임.
- 헷갈린 부분: 없음
- 복습 필요: [ ]

## 학습 메모 (패턴·알고리즘 정리, 복습 포인트 제안)

- 패턴/알고리즘
    - 시뮬레이션 + 불변식 체크: 매 스텝에서 규칙 위반 여부를 즉시 판단.
    - 중복 검사 자료구조 선택: HashSet으로 평균 O(1) 중복 체크.
    - 인덱스→사람/차례 매핑: player = i % n + 1, round = i / n + 1.
- 흔한 실수
    - 한 글자 단어 체크 누락, 연결성 검사 순서 오류, List.Contains로 인한 성능 저하.
- 복습 포인트
    - 해시셋/딕셔너리 활용 문제(중복/방문 체크) 더 풀어보기.
    - 시뮬레이션 문제에서 “위반 즉시 반환” 흐름으로 코드 간결화 연습.
    - 문자 비교 시 불필요한 LINQ 호출 지양, 인덱싱 습관화.