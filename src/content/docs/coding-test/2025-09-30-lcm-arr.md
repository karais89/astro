---
title: "N개의 최소공배수 (Lv.2)"
description: N개의 최소공배수 문제 풀이.
date: 2025-09-30"
tags: ["programmers"]
draft: false
preferBodyH1: true
---

# N개의 최소공배수 (Lv.2)

## 문제 요약

두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.

제한 사항
arr은 길이 1이상, 15이하인 배열입니다.
arr의 원소는 100 이하인 자연수입니다.

## 풀이 코드 (C#)

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int GCD(int a, int b)
    {
        while (b != 0)
        {
            (a, b) = (b, a % b);
        }
        
        return a;
    }
    
    public int LCM(int a, int b)
    {
        return a*b/GCD(a,b);
    }
    
    public int solution(int[] arr) {
        int answer = 0;
        
        Queue<int> q = new Queue<int>();
        for (int i = 0; i < arr.Length; i++)
        {
            q.Enqueue(arr[i]);
        }
        
        answer = q.Dequeue();
        while (q.Count > 0)
        {
            var b = q.Dequeue();
            answer = LCM(answer, b);
        }
        
        return answer;
    }
}
```

## 다른 사람의 풀이
```csharp
public class Solution {
    public int solution(int[] arr) {

        int answer = arr[0];

        for (int i = 1; i < arr.Length; ++i)
            answer *= arr[i] / Gcd(answer, arr[i]);

        return answer;
    }

    public int Gcd(int a, int b)
    {
        while (b != 0)
        {
            int r = a % b;
            a = b;
            b = r;
        }

        return a;
    }
}
```

## 개선된 코드

```csharp
using System;
using System.Linq;

public class Solution {
    public int Gcd(int a, int b) {
        while (b != 0) (a, b) = (b, a % b);
        return a;
    }

    public int Lcm(int a, int b) => a / Gcd(a, b) * b; // 오버플로우 방지 순서

    public int solution(int[] arr) {
        return arr.Aggregate((lcm, next) => Lcm(lcm, next));
    }
}
```

- Aggregate를 쓰면 "앞에서 구한 LCM에 다음 값을 합쳐나간다"는 의도가 직관적으로 드러남.
- a * b / Gcd(a, b) 대신 a / Gcd(a, b) * b로 순서를 바꿔 오버플로우 위험도 줄임.

## 메모

- 선택 포인트: 최소 공배수는 2개의 수를 가지고 구하는 것. 배열에서 받은 최소 공배수를 구하면 결국 나올 것이라고 생각함.
- 개선 가능: queue를 사용하지 않아도 될 것 같기도 했지만, 뭔가 더 가독성 있어보여 사용함.
- 주의할 부분: 오버플로우 발생 가능성이 있으므로 lcm 구할때 순서 변경

## 학습 메모

- 핵심 패턴: 유클리드 호제법(GCD) + LCM 공식 (a * b / gcd(a,b)).
- 배운 점: 여러 수의 LCM도 2개씩 차례로 구하면 전체 LCM이 된다.
- 복습 포인트:
  - GCD 구현 (재귀 vs 반복).
  - 오버플로우 방지용 곱셈 순서.
  - C# Aggregate 활용해 가독성 높이는 방법.


## 📌 LINQ `Aggregate` 정의

* **정의**: 시퀀스(배열, 리스트 등)의 각 요소를 왼쪽부터 차례대로 누적 함수에 적용해 **단일 결과값**을 만들어내는 LINQ 메서드.
* **형태**:

  ```csharp
  source.Aggregate((acc, next) => /* 누적 처리 */);
  ```

  * `acc`: 지금까지의 누적값 (accumulator)
  * `next`: 현재 처리할 요소

---

### 📌 예제 코드

#### 1. 합계 구하기

```csharp
int[] arr = { 1, 2, 3, 4 };
int sum = arr.Aggregate((acc, next) => acc + next);
// (((1+2)+3)+4) = 10
```

#### 2. 최소공배수 구하기

```csharp
int Gcd(int a, int b) {
    while (b != 0) (a, b) = (b, a % b);
    return a;
}
int Lcm(int a, int b) => a / Gcd(a, b) * b;

int[] arr = { 2, 6, 8 };
int lcm = arr.Aggregate((acc, next) => Lcm(acc, next));
// Lcm(Lcm(2,6),8) = 24
```