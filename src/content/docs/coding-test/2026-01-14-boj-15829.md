---
title: "BOJ 15829 Hashing"
description: "문자열의 해시 값을 계산하는 문제에서 모듈로 연산과 오버플로우 처리 방법 풀이."
date: 2026-01-14
tags: ["boj", "bronze", "hashing", "modulo"]
draft: false
preferBodyH1: true
---

# BOJ 15829 Hashing

## 문제

문자열의 해시 값을 계산하는 문제다. 주어진 문자열에 대해 다음 해시 함수를 사용한다:

```
H = (a₁ × 31⁰ + a₂ × 31¹ + a₃ × 31² + ... + aₙ × 31ⁿ⁻¹) mod 1234567891
```

여기서 aᵢ는 i번째 문자를 숫자로 변환한 값이다 (a=1, b=2, ..., z=26).

## 입력

- 첫째 줄: 문자열의 길이 L (1 ≤ L ≤ 50)
- 둘째 줄: 영문 소문자로만 이루어진 문자열

## 출력

- 주어진 해시 함수를 사용하여 계산한 해시 값

## 접근

### 핵심 포인트

1. **모듈로 연산의 분배법칙**: (A + B) mod M = ((A mod M) + (B mod M)) mod M
2. **오버플로우 방지**: 중간 계산 과정에서 `long` 타입 사용 및 매 단계마다 모듈로 연산 적용
3. **거듭제곱 계산**: 31의 거듭제곱을 매번 계산하되, 모듈로 연산을 적용하여 크기 제한

### 주의사항

- `int` 타입으로는 중간 계산 과정에서 오버플로우 발생
- 거듭제곱 값이 매우 커지므로 각 단계마다 모듈로 연산 필요
- 곱셈 후 모듈로 연산, 덧셈 후 모듈로 연산을 꼭 수행해야 함

### 알고리즘

1. 문자열을 한 글자씩 순회
2. 각 문자를 숫자로 변환 (a=1, b=2, ...)
3. 해당 위치의 31의 거듭제곱을 계산 (모듈로 연산 적용)
4. `(문자값 × 31ⁱ) mod M`을 계산하여 누적
5. 최종 해시 값 출력

## 풀이 코드 (C#)

```csharp
using System;

string _ = Console.ReadLine();
string str = Console.ReadLine();
const int modValue = 1234567891;
long hashSum = 0;

for (int i = 0; i < str.Length; i++)
{
    char c = str[i];
    int value = c - 'a' + 1;
    long powValue = CustomPow(31, i, modValue);
    long hash = (value * powValue) % modValue;
    hashSum = (hashSum + hash) % modValue;
}

Console.WriteLine(hashSum);

static long CustomPow(int baseValue, int exponent, int modValue)
{
    long result = 1;
    for (int i = 0; i < exponent; i++)
    {
        result = (result * baseValue) % modValue;
    }
    return result;
}
```

## 예제

### 예제 1
- 입력: 
  ```
  1
  i
  ```
- 출력: `9`
- 설명: 
  - i = 9번째 알파벳
  - H = 9 × 31⁰ = 9 × 1 = 9

### 예제 2
- 입력:
  ```
  5
  abcde
  ```
- 출력: `4739715`
- 설명:
  - a=1, b=2, c=3, d=4, e=5
  - H = (1×1 + 2×31 + 3×961 + 4×29791 + 5×923521) mod 1234567891
  - H = 4739715

## 메모

- 핵심 아이디어: **모듈로 연산의 분배법칙**을 활용한 오버플로우 방지
- 매 단계마다 모듈로 연산을 적용하지 않으면 큰 입력에서 실패
- `long` 타입 사용 필수 (`int`로는 오버플로우 발생)
- 해싱 알고리즘의 기본 원리를 배울 수 있는 문제
- 시간 복잡도: O(L²) - CustomPow 함수가 O(i)이므로 전체 O(L²)
- 복습 필요: [ ]
