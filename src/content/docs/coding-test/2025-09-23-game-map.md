---
title: "게임 맵 최단거리 (Lv.2)"
description: 게임 맵 최단거리 문제 풀이.
date: 2025-09-23"
tags: ["programmers", "DFS", "BFS"]
draft: false
preferBodyH1: true
---

# 게임 맵 최단거리 (Lv.2)

## 문제 요약

문제 설명
ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.

지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.

최단거리1_sxuruo.png

위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.
아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.

첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.
최단거리2_hnjd3b.png

두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.
최단거리3_ntxygd.png

위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.

만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.

최단거리4_of9xfg.png

게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.


## 풀이 코드 (C#)

```csharp
using System;
using System.Collections.Generic;

class Solution {
    public int solution(int[,] maps) {
        int answer = 0;
        
        // DFS vs BFS (최단 거리의 경우 BFS)
        // 0 = 벽, 1 = 길
        // 시작 0, 0, 목표 n-1, m-1
        bool[,] visted = new bool[maps.GetLength(0), maps.GetLength(1)];
        int[,] dist = new int[maps.GetLength(0), maps.GetLength(1)];
        Queue<(int row, int col)> q = new Queue<(int,int)>();
        
        dist[0,0] = 1;
        q.Enqueue((0,0));
        visted[0, 0] = true;
        
        while (q.Count > 0)
        {
            var (row, col) = q.Dequeue();
            int nextDist = dist[row, col] + 1;
             
            // 상,하,좌,우
            // queue 검사 후 넣기
            int up = row - 1;
            if (up >= 0 && maps[up, col] == 1 && !visted[up, col])
            {
                q.Enqueue((up, col));
                dist[up, col] = nextDist;
                visted[up, col] = true;
            }
            
            int down = row + 1;
            if (down < maps.GetLength(0) && maps[down, col] == 1 && !visted[down, col])
            {
                q.Enqueue((down, col));
                dist[down, col] = nextDist;
                visted[down, col] = true;
            }
            
            int left = col - 1;
            if (left >= 0 && maps[row, left] == 1 && !visted[row, left])
            {
                q.Enqueue((row, left));
                dist[row, left] = nextDist;
                visted[row, left] = true;
            }
            
            int right = col + 1;
            if (right < maps.GetLength(1) && maps[row, right] == 1 && !visted[row, right])
            {
                q.Enqueue((row, right));
                dist[row, right] = nextDist;
                visted[row, right] = true;
            }
        }
        
        var val = dist[maps.GetLength(0) - 1, maps.GetLength(1) - 1];
        return val == 0 ? -1 : val;
    }
}
```

## 다른 사람 풀이

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

class Solution 
{
    public int solution(int[,] maps)
    {    
        int[,] nCosts = new int[maps.GetLength(0), maps.GetLength(1)];
        Queue<Map> que = new Queue<Map>();
        que.Enqueue(new Map(0, 0, 1));
        nCosts[0, 0] = 1;        
        while (que.Count() > 0)
        {
            Map map = que.Dequeue();
            int x = map.X;
            int y = map.Y;

            // 상하좌우 살펴서
            if (y > 0 && maps[y - 1, x] == 1)   // 상
            {
                if (nCosts[y - 1, x] == 0 || nCosts[y - 1, x] > map.Cost + 1)
                {
                    nCosts[y - 1, x] = map.Cost + 1;
                    que.Enqueue(new Map(x, y - 1, map.Cost + 1));
                }
            }
            if (y < maps.GetLength(0) - 1 && maps[y + 1, x] == 1)  // 하
            {
                if (nCosts[y + 1, x] == 0 || nCosts[y + 1, x] > map.Cost + 1)
                {
                    nCosts[y + 1, x] = map.Cost + 1;
                    que.Enqueue(new Map(x, y + 1, map.Cost + 1));
                }
            }
            if (x > 0 && maps[y, x - 1] == 1)  // 좌
            {
                if (nCosts[y, x - 1] == 0 || nCosts[y, x - 1] > map.Cost + 1)
                {
                    nCosts[y, x - 1] = map.Cost + 1;
                    que.Enqueue(new Map(x - 1, y, map.Cost + 1));
                }
            }
            if (x < maps.GetLength(1) - 1 && maps[y, x + 1] == 1)  // 우
            {
                if (nCosts[y, x + 1] == 0 || nCosts[y, x + 1] > map.Cost + 1)
                {
                    nCosts[y, x + 1] = map.Cost + 1;
                    que.Enqueue(new Map(x + 1, y, map.Cost + 1));
                }
            }
        }
        return nCosts[maps.GetLength(0) - 1, maps.GetLength(1) - 1] == 0 ? -1 : nCosts[maps.GetLength(0) - 1, maps.GetLength(1) - 1];
    }    
}

public class Map
{
    public int X { get; set; }
    public int Y { get; set; }
    public int Cost { get; set; }
    public Map(int x, int y, int cost)
    {
        this.X = x;
        this.Y = y;
        this.Cost = cost;
    }
}
```

## 개선 코드

- 개선 코드 2가지 버전, 두 버전 모두 visited 변수는 제거 (DIST로 확인 가능)
- 4 방향 체크에 대한 중복 로직 제거 버전 (다른 방향)

### 개선 코드 1 — 헬퍼 메서드 버전 (가독성 ↑)

```csharp
using System;
using System.Collections.Generic;

class Solution {
    private void TryMove(int r, int c, int nr, int nc, int[,] maps, int[,] dist, Queue<(int,int)> q) {
        if (nr < 0 || nr >= maps.GetLength(0)) return;
        if (nc < 0 || nc >= maps.GetLength(1)) return;
        if (maps[nr, nc] == 0) return;
        if (dist[nr, nc] != 0) return;

        dist[nr, nc] = dist[r, c] + 1;
        q.Enqueue((nr, nc));
    }

    public int solution(int[,] maps) {
        int n = maps.GetLength(0);
        int m = maps.GetLength(1);
        int[,] dist = new int[n, m];
        Queue<(int, int)> q = new Queue<(int, int)>();

        dist[0, 0] = 1;
        q.Enqueue((0, 0));

        while (q.Count > 0) {
            var (r, c) = q.Dequeue();

            TryMove(r, c, r - 1, c, maps, dist, q); // 상
            TryMove(r, c, r + 1, c, maps, dist, q); // 하
            TryMove(r, c, r, c - 1, maps, dist, q); // 좌
            TryMove(r, c, r, c + 1, maps, dist, q); // 우
        }

        int result = dist[n - 1, m - 1];
        return result == 0 ? -1 : result;
    }
}
```

- 장점: 직관적이고 읽기 쉬움 (실무 스타일에 가까움).
- 단점: 네 방향이 그대로 남아 있음 → 코드 압축력은 덜함.

### 개선 코드 2 — dr/dc 방향 배열 버전 (압축 ↑)

```csharp
using System;
using System.Collections.Generic;

class Solution {
    public int solution(int[,] maps) {
        int n = maps.GetLength(0);
        int m = maps.GetLength(1);
        int[,] dist = new int[n, m];
        Queue<(int, int)> q = new Queue<(int, int)>();

        int[] dr = { -1, 1, 0, 0 };
        int[] dc = { 0, 0, -1, 1 };

        dist[0, 0] = 1;
        q.Enqueue((0, 0));

        while (q.Count > 0) {
            var (r, c) = q.Dequeue();

            for (int i = 0; i < 4; i++) {
                int nr = r + dr[i];
                int nc = c + dc[i];

                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                if (maps[nr, nc] == 0 || dist[nr, nc] != 0) continue;

                dist[nr, nc] = dist[r, c] + 1;
                q.Enqueue((nr, nc));
            }
        }

        int result = dist[n - 1, m - 1];
        return result == 0 ? -1 : result;
    }
}
```

- 장점: 중복 완전 제거, 짧고 알고리즘 문제에서 표준.
- 단점: dr/dc 패턴에 익숙하지 않으면 처음엔 가독성이 떨어짐.

## 메모

- 선택 포인트: 길 찾기 알고리즘으로 길 찾기. 최단 거리 이므로 BFS 사용
- 개선 가능: visited 변수를 없애고, 중복되는 코드 제거 하고, 가독성 개선
- 주의할 부분: 2차원 배열에서 접근 범위. 방문한 영역 재 방문 되지 않도록 진행