---
title: "BOJ 11651 좌표 정렬하기 2"
description: y좌표 우선, x좌표 차순으로 좌표 정렬 문제 풀이.
date: 2026-02-10
tags: ["boj", "silver", "sorting"]
draft: false
preferBodyH1: true
---

# BOJ 11651 좌표 정렬하기 2

## 문제 설명

2차원 평면 위의 점 N개가 주어진다. 좌표를 y좌표가 증가하는 순으로, y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.

입력
- 첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다.
- 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000) 
- 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.

출력
- 첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.

## 풀이 코드 (C#)

```csharp
int n = int.Parse(Console.ReadLine()!);
(int x, int y)[] points = new (int x, int y)[n];
for (int i = 0; i < n ; i++)
{
    string[] value = Console.ReadLine()!.Split();
    int x = int.Parse(value[0]);
    int y = int.Parse(value[1]);
    points[i] = (x,y);
}

Array.Sort(points, (a, b) =>
{
    if (a.y == b.y)
    {
        return a.x.CompareTo(b.x);
    } 
    
    return a.y.CompareTo(b.y);
});

for (int i = 0 ; i < points.Length; i++)
{
    Console.WriteLine($"{points[i].x} {points[i].y}");
}
```

## 개선 코드 (LINQ)

```csharp
using System;
using System.Linq;

var n = int.Parse(Console.ReadLine()!);
var points = Enumerable.Range(0, n)
    .Select(_ => Console.ReadLine()!.Split().Select(int.Parse).ToArray())
    .Select(arr => (x: arr[0], y: arr[1]))
    .OrderBy(p => p.y)
    .ThenBy(p => p.x);

foreach (var p in points)
{
    Console.WriteLine($"{p.x} {p.y}");
}
```

- LINQ의 `OrderBy().ThenBy()`를 사용하면 더 선언적이고 간결하게 작성 가능.
- 하지만 현재 풀이의 `Array.Sort`와 성능은 거의 동일하며, 오히려 현재 코드가 더 명확함.

## 메모

- 선택 포인트: 튜플 `(int x, int y)`로 좌표 쌍을 관리하고, 커스텀 비교자를 사용한 정렬.
- 개선 가능: LINQ를 사용할 수 있지만, 현재 코드가 더 명확하고 직관적임.
- 주의할 부분: y좌표가 같을 때 x좌표로 정렬하는 2차 정렬 조건을 빠뜨리지 않기.

## 학습 메모

- 패턴: 다중 기준 정렬(Multi-key sorting) 문제. y좌표 우선, x좌표 차순.
- 시간 복잡도: O(N log N) - 정렬 알고리즘의 표준 복잡도.
- 복습 포인트:
  - `Array.Sort`의 커스텀 비교자(Comparison<T> delegate) 작성법.
  - `CompareTo` 메서드: 음수(작음), 0(같음), 양수(큼) 반환.
  - C# 튜플의 명명된 필드 사용법 `(int x, int y)`.
  - LINQ `OrderBy().ThenBy()` vs `Array.Sort` 비교.
