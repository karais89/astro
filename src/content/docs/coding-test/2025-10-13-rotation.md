---
title: "괄호 회전하기 (Lv.2)"
description: 괄호 회전하기 문제 풀이.
date: 2025-10-13"
tags: ["programmers"]
draft: false
preferBodyH1: true
---

# 괄호 회전하기 (Lv.2)

## 문제 요약

다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.

- (), [], {} 는 모두 올바른 괄호 문자열입니다.
- 만약 A가 올바른 괄호 문자열이라면, (A), [A], {A} 도 올바른 괄호 문자열입니다. 예를 들어, [] 가 올바른 괄호 문자열이므로, ([]) 도 올바른 괄호 문자열입니다.
- 만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, {} 와 ([]) 가 올바른 괄호 문자열이므로, {}([]) 도 올바른 괄호 문자열입니다.

대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 x (0 ≤ x < (s의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.

## 풀이 코드 (C#)

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int solution(string s) {
        int answer = 0;
        
        // 1. 회전 반복 (돌아올때 까지?)
        int repeatCount = s.Length;
        for (int i = 0; i < repeatCount; i++)
        {
            var newStr = s.Substring(i) + s.Substring(0, i);
            // 2. 올바른 괄호 인지 판단 (개수 증가)
            if (ValidateStr(newStr))
            {
                answer++;
            }
        }
    
        return answer;
    }
    
    public bool ValidateStr(string s)
    {
        var stackStr = new Stack<char>();
        foreach (var c in s)
        {
            switch (c)
            {
                case '[':
                case '(':
                case '{':
                    stackStr.Push(c);
                    break;  
            }
            
            switch (c)
            {
                case ']':
                case ')':
                case '}':
                    if (stackStr.Count == 0)
                    {
                        return false;
                    }
                    var st = stackStr.Pop();
                    if (st == '[' && c != ']')
                    {
                       return false; 
                    }
                    
                    if (st == '(' && c != ')')
                    {
                        return false;
                    }
                    
                    if (st == '{' && c != '}')
                    {
                        return false;
                    }
                    
                    break;
            }
        }
        
        return stackStr.Count == 0;
    }
}
```

## 다른 사람의 풀이

```csharp
using System;
using System.Collections.Generic;

public class Solution
{
    public int solution(string s)
    {
        int answer = 0;
        var stack = new Stack<char>();
        var queue = new Queue<char>();
        foreach (var item in s)
            queue.Enqueue(item);
        for (int i = 0; i < queue.Count - 1; i++)
        {
            stack.Clear();
            answer += Check(queue, stack);
            queue.Enqueue(queue.Dequeue());
        }

        return answer;
    }

    private int Check(Queue<char> queue, Stack<char> stack)
    {
        foreach (var item in queue)
        {
            if (item == '[' || item == '(' || item == '{')
                stack.Push(item);
            else if (stack.Count == 0)
                return 0;
            else if (stack.Peek() == '[' && item != ']')
                return 0;
            else if (stack.Peek() == '(' && item != ')')
                return 0;
            else if (stack.Peek() == '{' && item != '}')
                return 0;
            else
                stack.Pop();
        }
        if (stack.Count != 0)
            return 0;

        return 1;
    }
}
```

## 리팩토링 버전

```csharp
public class Solution {
    public int solution(string s) {
        int count = 0;
        for (int i = 0; i < s.Length; i++) {
            string rotated = s[i..] + s[..i];
            if (IsValid(rotated)) count++;
        }
        return count;
    }

    private bool IsValid(string s) {
        Stack<char> stack = new();
        foreach (char c in s) {
            if (c is '(' or '[' or '{') stack.Push(c);
            else {
                if (stack.Count == 0) return false;
                char open = stack.Pop();
                if ((open == '(' && c != ')') ||
                    (open == '[' && c != ']') ||
                    (open == '{' && c != '}'))
                    return false;
            }
        }
        return stack.Count == 0;
    }
}

```

- 최신 C# 문법 (is, 범위 연산자, 타입 추론) 사용
- switch 두 번 반복 제거 → 간결

## 메모

해당 문제는 스택과 문자열 회전 로직을 조합해 해결할 수 있음.
풀이에만 집중하다 보니 코드의 가독성과 메모리 효율성까지 신경 쓰지 못한 점이 아쉬웠음.

## 학습 메모

### 핵심 패턴

- Stack 기반 괄호 유효성 검증 패턴
- → 여는 괄호 Push, 닫는 괄호 시 Pop, 불일치 시 False
- 문자열 회전 처리
- → s[i..] + s[..i] 형태로 간결히 구현 가능

### 복습 포인트

- Stack과 Queue의 차이 (선입후출 vs 선입선출)
- 문자열 슬라이싱 (Substring, Range, Span<char>)
- 복잡도 추정: O(n²) 구조에서도 입력 제한에 따라 실전 가능 여부 판단