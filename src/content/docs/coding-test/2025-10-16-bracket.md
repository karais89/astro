---
title: "예상 대진표 (Lv.2)"
description: 예상 대진표 문제 풀이.
date: 2025-10-16"
tags: ["programmers"]
draft: false
preferBodyH1: true
---

# 예상 대진표 (Lv.2)

## 문제 요약

### 문제 설명

△△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, ... , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다.

이때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 궁금해졌습니다. 게임 참가자 수 N, 참가자 번호 A, 경쟁자 번호 B가 함수 solution의 매개변수로 주어질 때, 처음 라운드에서 A번을 가진 참가자는 경쟁자로 생각하는 B번 참가자와 몇 번째 라운드에서 만나는지 return 하는 solution 함수를 완성해 주세요. 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다.

## 풀이 코드 (C#)

```csharp
using System;

class Solution
{
    public int solution(int n, int a, int b)
    {
        int answer = 0;
        
        // 알려준 로직 그대로 풀면 되지 않을까 싶긴 함.
        // n = 게임 참가자 수, a = 번호, b = 번호
        int aNum = a;
        int bNum = b;
        for (int i = 0 ; i < n; i++)
        {   
            if (aNum % 2 == 0)
            {
                aNum /= 2;
            }
            else
            {
                aNum = (aNum + 1) / 2;
            }
            
            if (bNum % 2 == 0)
            {
                bNum /= 2;
            }
            else
            {
                bNum = (bNum + 1) / 2;
            }
            
            if (aNum == bNum)
            {
                answer = i;
                break;
            }
        }
    
        return answer + 1;
    }
}
```

## 다른 사람의 풀이

```csharp
using System;

class Solution
{
    public int solution(int n, int a, int b)
    {
        int round = 0;
        while(a != b)
        {
            a = a/2 + a%2;
            b = b/2 + b%2;
            round++;
        }

        return round;
    }
}

```

## 더 짧은 버전

```csharp
using System;

class Solution
{
    public int solution(int n, int a, int b)
    {
        int answer = 0;
        int aNum = a;
        int bNum = b;

        while (true)
        {
            if (aNum == bNum)
            {
                return answer;
            }

            aNum = (aNum + 1) / 2;
            bNum = (bNum + 1) / 2;
            answer++;
        }

        return answer;
    }
}
```

- 이 쪽이 조금 더 깔끔한 버전이지 않을까 싶음.

## 메모

- 토너먼트 결정 방식. 결국 같은 수가 나와야 됨 (나누기 2). 조금 해맨 부분이 없지 않아 있음

## 🧩 학습 메모

- 이 문제는 “토너먼트 시뮬레이션” 유형으로, 결국 “두 수가 같아질 때까지 반으로 나누기” 문제.
- 핵심 패턴은 (num + 1) / 2 → 짝수는 그대로, 홀수는 올림(ceil) 효과.
- 비슷한 패턴이 나오는 문제:
  - “게임 맵 최단거리” → BFS지만 반복적으로 상태 갱신
  - “다음 큰 숫자” → 비트 연산 기반 상태 변화
  - “짝지어 제거하기” → 조건 만족할 때까지 스택 반복