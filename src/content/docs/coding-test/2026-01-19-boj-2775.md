---
title: "BOJ 2775 부녀회장이 될테야"
description: "동적 계획법을 사용하여 아파트 층별 거주민 수를 계산하는 문제 풀이."
date: 2026-01-19
tags: ["boj", "bronze", "dp", "math"]
draft: false
preferBodyH1: true
---

# BOJ 2775 부녀회장이 될테야

## 문제

평소 반상회에 참석하는 것을 좋아하는 주희는 이번 기회에 부녀회장이 되고자 한다. 부녀회장이 되기 위해서는 다음과 같은 조건을 만족해야 한다.

**조건**: "a층의 b호에 살려면 자신의 아래(a-1)층의 1호부터 b호까지 사람들의 수의 합만큼 사람들을 데려와 살아야 한다"

아파트에 비어있는 집은 없고 모든 거주민들이 이 조건을 지키고 있을 때, 주어지는 층과 호수에 몇 명이 살고 있는지 출력하라.

**단, 아파트에는 0층부터 있고 각층에는 1호부터 있으며, 0층의 i호에는 i명이 산다.**

## 입력

- 첫째 줄: 테스트 케이스의 수 T
- 각 테스트 케이스마다:
  - 첫째 줄: 층 수 k (0 ≤ k ≤ 14)
  - 둘째 줄: 호수 n (1 ≤ n ≤ 14)

## 출력

- 각 테스트 케이스마다 해당 층, 해당 호에 거주하는 사람의 수를 출력

## 접근

이 문제는 동적 계획법(DP)으로 푸는 전형적인 문제이다.

### 점화식

- **0층**: `dp[0][i] = i` (0층 i호에는 i명이 거주)
- **k층 n호**: `dp[k][n] = dp[k-1][1] + dp[k-1][2] + ... + dp[k-1][n]`

즉, 각 호수는 바로 아래층의 1호부터 해당 호수까지의 합이다.

### 예시

```
층\호   1   2   3   4
0층    1   2   3   4
1층    1   3   6  10
2층    1   4  10  20
3층    1   5  15  35
```

### 알고리즘

1. 최대 크기(15x15)의 2차원 DP 배열을 미리 계산
2. 0층 초기화 후, 각 층마다 호수 순서대로 누적합 계산
3. 쿼리마다 O(1)로 답 출력

## 풀이 코드 (C#)

```csharp
using System;

int count = int.Parse(Console.ReadLine()!);
const int maxVal = 15;
int[,] dp = new int[maxVal, maxVal];

// 0층 초기화
for (int i = 0; i < maxVal; i++)
{
    dp[0, i] = i;
}

// DP 테이블 채우기 (0층 제외)
for (int i = 1; i < maxVal; i++)
{
    for (int j = 0; j < maxVal; j++)
    {
        for (int k = 0; k <= j; k++)
        {
            dp[i, j] += dp[i - 1, k];
        }
    }
}

// 쿼리 처리
for (int i = 0; i < count; i++)
{
    int k = int.Parse(Console.ReadLine()!);
    int n = int.Parse(Console.ReadLine()!);

    Console.WriteLine(dp[k, n]);
}
```

## 메모

- 핵심 아이디어: 각 칸은 바로 아래층의 누적합
- DP 배열을 미리 계산해두면 여러 쿼리를 빠르게 처리 가능
- 누적합 최적화: `dp[i][j] = dp[i][j-1] + dp[i-1][j]`로 O(n³) → O(n²) 개선 가능
- 복습 필요: [ ]
