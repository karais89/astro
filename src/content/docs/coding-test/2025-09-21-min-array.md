---
title: "최솟값 만들기 (Lv.2)"
description: 최솟값 만들기 문제 풀이.
date: 2025-09-21
tags: ["programmers"]
draft: false
preferBodyH1: true
---

# 최솟값 만들기 (Lv.2)

## 문제 요약

길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다.
배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)

## 풀이 코드 (C#)

```csharp
using System;

public class Solution {
    public int solution(int[] A, int[] B) {
        int answer = 0;
        Array.Sort(A);
        Array.Sort(B);
        Array.Reverse(B);
        for (int i = 0; i < A.Length; i++)
        {
           answer += (A[i] * B[i]);
        }
        
        return answer;
    }
}
```

## 다른 사람 풀이

```csharp
using System.Linq;

public class Solution
{
    public int solution(int[] A, int[] B)
    {
        return A.OrderBy(x => x).Zip(B.OrderByDescending(x => x), (a, b) => a * b).Sum();
    }
}
```

- Linq 사용하면 한줄로 해결이 가능.
- 가독성 측면에서는 잘 모르겠다.
- Zip 기능은 두 배열을 묶어주는 기능

## 메모

- 선택 포인트: 두 배열을 곱해서
- 개선 가능: linq를 사용하는 방법도 고려해볼만 함.
- 주의할 부분: 없음

## 학습 메모

- 패턴: 그리디(작은 값 ↔ 큰 값 매칭)
- LINQ 학습 포인트: OrderBy, OrderByDescending, Zip, Sum
- 복습 포인트:
    - Zip은 두 컬렉션을 같은 인덱스끼리 묶어 처리할 때 유용.
    - 가독성 vs 성능 트레이드오프: 문제 크기에 따라 선택.
    - 그리디 전략이 자주 나오는 문제 → "정렬 후 매칭" 패턴 익혀두기.