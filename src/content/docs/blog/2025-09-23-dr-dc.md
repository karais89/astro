---
title: "dr/dc 패턴 정리"
description: 격자 탐색 문제에서 자주 쓰이는 방향 배열(dr/dc) 패턴을 정리합니다.
date: 2025-09-23
tags: ["coding-test", "grid", "DFS", "BFS"]
draft: false
template: splash
related:
  - "/blog/2025-09-23-dfs-bfs"
---

## 도입부
코딩테스트 문제를 풀다 보면 2차원 배열에서 상하좌우로 이동하는 경우가 정말 많습니다.
처음에는 네 방향을 일일이 `if`문으로 쓰곤 했는데, 코드가 길어지고 중복이 많아지더라고요.
찾아보니 많은 사람들이 `dr/dc`라는 패턴으로 방향 이동을 간단히 처리하길래 정리해 두기로 했습니다.

## 기본 4방향 탐색
```csharp
int[] dr = { -1, 1, 0, 0 }; // 상, 하, 좌, 우
int[] dc = { 0, 0, -1, 1 };

for (int i = 0; i < 4; i++) {
    int nr = r + dr[i];
    int nc = c + dc[i];
    if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
    // (nr, nc)에서 필요한 작업 수행
}
```

이렇게 쓰면 네 방향을 한 번에 처리할 수 있어서 코드가 훨씬 간결해집니다.

## 확장 예시

### 대각선 포함 8방향

상하좌우뿐만 아니라 대각선까지 포함해서 총 8방향으로 움직이는 경우입니다.
예를 들어, 섬의 개수 세기 같은 문제(백준 4963)에서 사용합니다.

```csharp
int[] dr = { -1,-1,-1, 0, 0, 1, 1, 1 };
int[] dc = { -1, 0, 1,-1, 1,-1, 0, 1 };
```

이 배열을 쓰면 현재 위치 (r, c)에서 다음 8칸을 탐색하게 됩니다:

```text
↖ ↑ ↗
←    →
↙ ↓ ↘
```

이렇게 방향 배열만 바꾸면 같은 코드 구조로 다른 이동 방식을 쉽게 구현할 수 있습니다.

## 장단점

- **장점**: 코드 중복 제거, 간결함, 실수 방지
- **단점**: 익숙하지 않으면 가독성이 떨어짐 (특히 실무 코드에서는 비추천)

## 내 생각

- 코딩테스트에서는 `dr/dc`가 거의 표준처럼 쓰이기 때문에 반드시 익숙해져야 한다.
- 하지만 실무에서라면 `Directions` 상수 배열이나 `MoveUp/Down/Left/Right` 같은 메서드를 쓰는 게 더 가독성이 좋을 것 같다.
- 즉, **코테에서는 압축 버전**, **실무에서는 명시적 버전**으로 나누어 생각하면 될 것 같다.