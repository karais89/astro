---
title: "GCD와 LCM 정리"
description: 코딩테스트 필수 수학 스니펫, 최대공약수(GCD)와 최소공배수(LCM).
date: 2025-09-23
tags: ["coding-test", "math", "csharp"]
draft: false
template: splash
---

코딩테스트 문제를 풀다 보면 자주 나오는 수학 패턴 중 하나가 **최대공약수(GCD)**와 **최소공배수(LCM)**입니다.  
처음에는 헷갈리기도 하고, 매번 검색하기도 귀찮아서 아예 정리해두기로 했습니다.

---

## 개념 정리

- **공약수**: 두 수를 나누는 모든 수  
- **최대공약수 (GCD, Greatest Common Divisor)**: 공약수 중 가장 큰 수  
- **공배수**: 두 수의 배수  
- **최소공배수 (LCM, Least Common Multiple)**: 공배수 중 가장 작은 수  

---

## 수학적 관계식

두 수 a, b에 대해 다음이 항상 성립합니다:

```text

a × b = GCD(a, b) × LCM(a, b)

```

따라서 LCM은 GCD를 이용해 간단히 구할 수 있습니다:

```text

LCM(a, b) = (a × b) / GCD(a, b)

```

---

## GCD 구하는 방법

### 1) 단순 방법

- a, b의 약수를 전부 구해서 공통된 값 중 가장 큰 걸 선택  
- 비효율적 (O(n))  

### 2) 유클리드 호제법 (Euclidean Algorithm)

- 더 효율적인 방법:  

```text

GCD(a, b) = GCD(b, a % b)

```

- b가 0이 되는 순간의 a가 최대공약수  
- 시간 복잡도: O(log(min(a, b)))  

예시:  

- gcd(48, 18) → 48 % 18 = 12
- gcd(18, 12) → 18 % 12 = 6  
- gcd(12, 6) → 12 % 6 = 0 → **GCD = 6**  
- LCM(48, 18) = (48 × 18) / 6 = 144  

---

## C# 코드 (반복문, 튜플 스왑)

```csharp
int GCD(int a, int b)
{
  while (b != 0)
  {
      (a, b) = (b, a % b);
  }
  return a;
}

int LCM(int a, int b)
{
  return a / GCD(a, b) * b;
}
````

- `(a, b) = (b, a % b)` 문법으로 `temp` 변수 제거
- 반복문 기반이라 스택 오버플로우 걱정 없음
- 가독성 좋고 실무/코테 모두 사용 가능

---

## C# 코드 (재귀 — 암기용)

```csharp
int GCD(int a, int b) => b == 0 ? a : GCD(b, a % b);
int LCM(int a, int b) => a / GCD(a, b) * b;
```

- 가장 짧고 외우기 좋은 버전
- 깊이가 O(log(min(a, b)))라 스택 오버플로우 위험은 사실상 없음

---

## 기억해둘 포인트

- **GCD**: `while (b != 0) (a, b) = (b, a % b);`
- **LCM**: `a / GCD(a, b) * b`
- **관계식**: `a × b = GCD × LCM`
- **응용**: 기약분수, 달력 문제, 배열 전체의 GCD/LCM 계산 등에서 활용 가능

---

## 마무리

> **“GCD는 유클리드, LCM은 a/gcd\*b”**

위 한 문장만 기억하세요.
