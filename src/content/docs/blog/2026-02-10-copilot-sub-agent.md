---
title: "Copilot 서브에이전트로 프로젝트 하나를 통째로 만들어 본 후기"
description: "GitHub Copilot의 runSubagent로 사람 코드 0줄, 커밋 70+개짜리 프로젝트를 완성한 경험기. 128K 컨텍스트 한계를 넘는 오케스트레이션 패턴 정리."
date: 2026-02-10
createdAt: 2026-02-10
tags: ["AI", "Copilot", "vibe-coding", "sub-agent", "orchestration"]
draft: false
template: splash
related:
  - href: "https://github.com/jungin-kim/copilot-ralph-wiggum-example"
    label: "Ralph Wiggum Orchestration 예제 (GitHub)"
  - href: "/blog/2026-02-03-gsd/"
    label: "GSD 후기 — AI 기반 프로젝트 관리의 또 다른 접근"
---

## 들어가며

코드 한 줄 안 치고 프로젝트 하나를 완성할 수 있을까?

최근 2\~3일간 GitHub Copilot의 **서브에이전트(`runSubagent`)** 기능을 활용해서, 사람이 직접 작성한 코드 **0줄**, 자동 생성된 커밋 **70개 이상**인 Todo CLI 프로젝트를 하나 만들어 봤다. 개념 설계만 내가 잡고, 구현·테스트·커밋·검증까지 전부 AI가 처리하는 **완전 바이브 코딩** 실험이었다.

> TL;DR
>
> - Copilot은 요청 당 과금이라 한 프롬프트에서 최대한 많은 작업을 처리하는 게 유리하다
> - 하지만 128K 컨텍스트 한계 때문에 작업이 쌓이면 "데이터 오염"이 발생한다
> - 서브에이전트는 이 딜레마를 해결한다 — 격리된 새 컨텍스트에서 작업을 위임하므로 메인 컨텍스트가 깨끗하게 유지된다
> - 여기에 PLAN/PROGRESS 추적 시스템을 더하면, 다음 세션에서도 작업을 이어갈 수 있다
> - 이 패턴을 "Ralph Wiggum 오케스트레이션"이라는 이름으로 템플릿화해서 공개했다

결과물 레포: [copilot-ralph-wiggum-example](https://github.com/jungin-kim/copilot-ralph-wiggum-example)

---

## 1. Copilot 과금 모델과 고민의 시작

최근 GitHub Copilot을 본격적으로 쓰기 시작하면서, 요금 구조에 대한 고민이 생겼다.

Copilot은 **토큰 사용량 기반이 아니라 요청(request) 당 과금** 방식이다. Claude API처럼 "입력 토큰 + 출력 토큰 = 비용"이 아니라, 프롬프트 한 번 보내면 한 번 과금된다. 그래서 이론적으로는 **한 프롬프트 안에서 최대한 많은 작업을 몰아넣는 게** 비용상 유리하다.

문제는 **컨텍스트 윈도우 한계**다. Copilot의 컨텍스트는 대략 128K 토큰 정도(모델 마다 상이)인데, 작업이 누적되면서 이전 대화·파일 내용·도구 호출 결과가 쌓이면 **데이터 오염(context rot)** 이 발생한다. AI가 앞에서 한 지시를 잊거나, 엉뚱한 파일을 수정하거나, 같은 실수를 반복하는 현상이다.

정리하면 이런 딜레마였다:

| 전략 | 장점 | 단점 |
|:---:|:---:|:---|
| 한 프롬프트에 많이 | 비용 효율적 | 컨텍스트 오염, 품질 저하 |
| 프롬프트를 쪼개기 | 품질 유지 | 비용 증가, 흐름 끊김 |

"비용은 아끼면서, 컨텍스트 오염도 막을 방법이 없을까?" — 이 질문이 서브에이전트 패턴을 찾게 된 계기였다.

---

## 2. 서브에이전트란?

### 개념

`runSubagent`는 Copilot Chat에서 **완전히 격리된 새 컨텍스트를 생성**하여 작업을 위임하는 기능이다. 메인 대화(오케스트레이터)가 서브에이전트를 호출하면, 서브에이전트는 자기만의 독립된 컨텍스트에서 작업을 수행하고, 결과만 돌려준 뒤 즉시 종료된다.

핵심은 **컨텍스트 격리**다:

- 메인 오케스트레이터의 컨텍스트는 서브에이전트의 작업 내용으로 오염되지 않는다
- 서브에이전트는 매번 깨끗한 상태에서 시작하므로, 이전 작업의 잔해가 품질에 영향을 주지 않는다
- 그런데 이 전체가 **하나의 premium request**로 처리된다

### 오케스트레이터 vs 서브에이전트

```
┌─────────────────────────────────────────┐
│        Main Orchestrator (메인)          │
│  - 루프 관리, 상태 추적                   │
│  - 코드 직접 수정 ❌                     │
│  - 서브에이전트 호출만 담당               │
│                                         │
│  ┌──────────┐  ┌──────────┐             │
│  │ SubAgent │  │ SubAgent │  ...        │
│  │ (Task 1) │  │ (Task 2) │             │
│  │ 격리 ctx  │  │ 격리 ctx │            │
│  └──────────┘  └──────────┘             │
│                                         │
│  → 각 서브에이전트는 1개 태스크만         │
│    구현 → 커밋 → 종료                    │
└─────────────────────────────────────────┘
```

이 구조의 장점:

- **비용 효율**: 1개의 premium request로 전체 프로젝트 구동 가능
- **컨텍스트 격리**: 서브에이전트마다 새 컨텍스트이므로 "message too big" 에러 회피
- **추적 가능성**: 모든 변경이 파일(PROGRESS.md)에 기록되고 커밋됨
- **재시작 가능**: 중간에 끊겨도 PROGRESS.md를 읽고 이어서 진행

---

## 3. Ralph Wiggum 오케스트레이션 패턴

이 서브에이전트 활용법을 체계화해서 **재사용 가능한 프롬프트 템플릿**으로 만든 것이 "Ralph Wiggum(RW) 오케스트레이션"이다.

### 워크플로우 요약

```
rw-init → rw-feature → rw-plan-* → rw-run-* → rw-archive
(1회)     (기능별)      (계획)      (자동 루프)   (수동)
```

각 단계의 역할:

| 단계 | 프롬프트 | 하는 일 |
|:---:|:---:|:---|
| 초기화 | `rw-init` | `.ai/` 워크스페이스 생성, 프로젝트 분석, 부트스트랩 태스크 1개 생성 |
| 기능 정의 | `rw-feature` | 한 줄 요약 → 12개 섹션의 상세 Feature 스펙 파일 생성 |
| 계획 | `rw-plan-lite/strict` | Feature를 3\~8개의 원자적 TASK 파일로 분해 |
| 실행 | `rw-run-lite/strict` | 무한 루프: 미완료 태스크를 서브에이전트에 위임 → 구현 → 커밋 → 반복 |
| 아카이브 | `rw-archive` | 완료된 태스크/로그를 아카이브로 이동, 컨텍스트 비대화 방지 |

### Lite vs Strict 모드

| 구분 | Lite | Strict |
|:---:|:---:|:---|
| 리뷰어 서브에이전트 | 없음 | 있음 (Acceptance Criteria 검증) |
| 리뷰 실패 추적 | 없음 | `REVIEW_FAIL (n/3)` → 3회 실패 시 에스컬레이션 |
| 태스크 수 | 3\~6개 | 3\~8개 |
| 적합 용도 | 소규모/빠른 기능 | 핵심/복잡한 기능 |

Strict 모드에서는 구현 서브에이전트가 작업을 끝내면, **리뷰어 서브에이전트**가 별도로 호출되어 Acceptance Criteria를 검증한다. 3회 연속 실패하면 `REVIEW-ESCALATE`가 발생하며 오케스트레이터가 중단되고, 사람이 개입해야 한다.

---

## 4. 실제 작업 과정

### Step 1: 초기화

프롬프트 하나(`rw-init`)를 실행하면 `.ai/` 워크스페이스가 자동으로 생성된다.

```
.ai/
├── CONTEXT.md       # 언어 정책 + 기계 파싱 토큰 계약
├── PLAN.md          # PRD + Feature Notes
├── PROGRESS.md      # 태스크 상태 테이블 + 실행 로그
├── features/        # Feature 스펙 파일들
└── tasks/           # 개별 태스크 정의
```

AI가 저장소를 분석해서 프로젝트 목표/범위/제약조건을 **자동 추론**한다. 사용자에게 질문하지 않는다 — "이 저장소는 Node.js + TypeScript 프로젝트이고, Commander.js를 사용하며, Todo CLI를 만드는 것이 목표입니다" 같은 식으로 알아서 파악한다.

### Step 2: Feature → Task 분해

`rw-feature`로 "Todo CRUD 기능"이라고 한 줄 입력하면, 12개 섹션(목적, 범위, Acceptance Criteria, 의존성, 엣지 케이스 등)이 포함된 상세 스펙 파일이 생성된다. 이 스펙을 `rw-plan-lite`가 소비해서 원자적 TASK 파일 3\~6개로 분해한다.

### Step 3: 자율 실행 루프

`rw-run-lite`를 실행하면 **무한 루프**가 시작된다:

1. `PROGRESS.md`에서 미완료 태스크 확인
2. 우선순위가 가장 높고 의존성이 충족된 태스크 1개 선택
3. `runSubagent`로 구현 서브에이전트 호출
4. 서브에이전트가 구현 → 빌드/테스트 → PROGRESS.md 업데이트 → Conventional Commit → 종료
5. 모든 태스크 완료될 때까지 1\~4 반복

이 과정에서 **오케스트레이터는 코드를 직접 수정하지 않는다**. 상태 추적과 서브에이전트 호출만 담당한다. 실제 구현은 전부 서브에이전트가 격리된 컨텍스트에서 처리한다.

### 결과: 70+ 커밋이 자동 생성

20개의 태스크가 순차적으로 처리되면서, Conventional Commit 형식(`feat:`, `fix:`, `test:`, `docs:`)의 커밋이 70개 이상 자동 생성됐다. 전부 서브에이전트가 만든 커밋이다.

---

## 5. PLAN/PROGRESS 추적 시스템

이 패턴의 핵심 인프라는 **파일 기반 상태 추적**이다. 데이터베이스나 외부 서비스 없이, `.ai/` 폴더의 마크다운 파일만으로 전체 프로젝트 상태를 관리한다.

### PLAN.md — 제품 요구사항의 원천

```markdown
# Plan

## Goal
Node.js + TypeScript 기반 Todo CLI 애플리케이션

## Scope
- CRUD 기능 (add, list, delete, update)
- JSON 파일 기반 영속 저장소
- 통계 기능 (stats)

## Feature Notes (append-only)
- 2026-02-07 FEATURE-todo-crud: Todo CRUD 기능
- 2026-02-08 FEATURE-stats: 통계 기능 추가
```

`Feature Notes` 섹션은 **append-only**다. 기존 내용을 수정하거나 삭제하지 않고, 새 기능이 추가될 때만 한 줄씩 덧붙인다. 이렇게 하면 "언제 무슨 기능이 추가됐는지"가 시간순으로 남는다.

### PROGRESS.md — 단일 진실 원천(SSOT)

```markdown
## Task Status
| Task | Title | Status | Commit |
|------|-------|--------|--------|
| TASK-01 | 프로젝트 부트스트랩 | completed | feat: bootstrap project |
| TASK-02 | Todo 모델 정의 | completed | feat: add Todo model |
| TASK-03 | 저장소 구현 | in-progress | - |
| TASK-04 | add 명령어 | pending | - |

## Log
- **2026-02-07** — TASK-01 completed: 프로젝트 초기 구조 생성
- **2026-02-07** — TASK-02 completed: Todo 타입 정의 및 테스트
- **2026-02-08** — TASK-03 started: JSON 파일 저장소 구현 시작
```

이 파일이 **"단일 진실 원천(Single Source of Truth)"** 이다. 오케스트레이터도, 서브에이전트도, 사람도 이 파일을 보고 현재 상태를 파악한다.

중요한 규칙:

- `Task Status`, `Log`, 상태값(`pending`, `in-progress`, `completed`) 같은 **토큰은 영문 고정** — 기계 파싱 계약이다
- 서브에이전트가 태스크를 완료하면 이 파일을 직접 업데이트한다
- 아카이브 전까지 모든 로그가 이 파일에 누적된다

### 아카이브 전략

PROGRESS.md가 비대해지면(8000자 초과, completed 20개 초과) `rw-archive`를 실행해서 완료된 태스크 행과 오래된 로그를 `progress-archive/`로 이동한다. 단, **리뷰 실패/에스컬레이션 로그는 절대 아카이브하지 않는다** — 문제 패턴을 추적해야 하기 때문이다.

이 추적 시스템 덕분에 **세션이 끊겨도 다음에 이어서 작업할 수 있다**. 새 대화를 열고 `rw-run-lite`를 실행하면, 오케스트레이터가 PROGRESS.md를 읽고 "TASK-03이 in-progress니까 여기서부터 이어가자"라고 판단한다.

---

## 6. 바이브 코딩으로 검증까지

이 프로젝트에서 재미있었던 점은, **검증 과정 자체도 바이브 코딩**으로 진행했다는 것이다.

### 검증 리포트 자동 생성

프로젝트가 완성된 후, "이 오케스트레이션 워크플로우가 제대로 동작하는지 검증해줘"라는 프롬프트를 던졌다. AI가 알아서 검증 리포트를 작성했다:

- **P1 (Critical): 0건** — 즉시 중단 필요한 이슈 없음
- **P2 (High): 2건** — Lite 모드의 아카이브 후 태스크 재등록 버그, Strict 모드의 에스컬레이션 복구 경로 문서 미비
- **P3 이하**: 경미한 이슈들

P2 이슈도 이후 바이브 코딩으로 수정했다. "개념만 잡고, 나머지는 전부 AI"라는 접근이 검증 단계까지 통한 셈이다.

### 템플릿 추출

프로젝트를 다른 레포에서도 재사용할 수 있도록, `scripts/extract-template.sh`로 **11개 핵심 파일**을 추출하는 스크립트도 만들어 뒀다:

- 7개 프롬프트 (`.github/prompts/rw-*.prompt.md`)
- 4개 구조 파일 (`CONTEXT.md`, `GUIDE.md`, `FEATURE-TEMPLATE.md`, `features/README.md`)

언어/프레임워크에 종속되지 않게 설계했기 때문에, Node.js가 아닌 Python이든 Unity든 **어떤 프로젝트에서든** 이 템플릿을 가져다 쓸 수 있다.

---

## 7. 느낀 점 / 장단점 정리

### 👍 좋았던 점

- **비용 효율이 실제로 좋다**: 1 premium request로 프로젝트 전체를 돌릴 수 있다. 토큰 기반 과금이었으면 훨씬 비쌌을 작업량이다.
- **컨텍스트 오염이 사라진다**: 서브에이전트마다 깨끗한 컨텍스트에서 시작하니, 50번째 태스크도 1번째와 동일한 품질로 처리된다.
- **추적 가능성**: PROGRESS.md에 모든 변경 내역이 남으니, "AI가 뭘 했는지" 항상 알 수 있다. git log와 PROGRESS.md를 같이 보면 감사 추적(audit trail)도 된다.
- **재시작이 자유롭다**: 세션이 끊겨도, 새 대화에서 PROGRESS.md를 읽으면 이어서 진행 가능하다. 이건 긴 작업에서 정말 큰 장점이다.

### 🤔 아쉬운 점 / 한계

- **초기 프롬프트 설계 비용**: 7개 프롬프트 파일을 만드는 데 상당한 시간이 들었다. 물론 한 번 만들면 재사용하지만, 처음 투자가 적지 않다.
- **디버깅 시 사람 개입**: 서브에이전트가 빌드 에러를 스스로 고치지 못하는 경우가 가끔 있다. Strict 모드의 리뷰어가 이를 잡아주긴 하지만, 3번 실패하면 결국 사람이 봐야 한다.
- **동시성 제약**: 서브에이전트는 순차적으로 1개씩만 실행된다. GSD처럼 병렬 실행이 안 되므로, 태스크가 많으면 시간이 오래 걸린다.
- **정밀한 제어가 어렵다**: 오케스트레이터가 서브에이전트에 "이 파일의 이 함수를 이렇게 고쳐"라고 정밀 지시하기보다는, 태스크 단위로 큰 방향만 제시하는 구조다. 세밀한 코드 리뷰가 필요한 경우에는 직접 보는 게 낫다.

---

## GSD와의 비교

[이전 글](../2026-02-03-gsd/)에서 다뤘던 GSD와 이번 RW 오케스트레이션을 비교하면:

| 항목 | GSD | RW 오케스트레이션 |
|:---:|:---:|:---|
| **런타임** | Claude Code / OpenCode / Gemini CLI | GitHub Copilot (runSubagent) |
| **과금 방식** | 토큰 기반 (모델에 따라 다름) | 요청 기반 (Copilot premium request) |
| **컨텍스트 관리** | phase 단위로 분리 + 문서 고정 | 서브에이전트 격리 (물리적으로 새 컨텍스트) |
| **병렬 실행** | 병렬 서브 에이전트 지원 | 순차 실행만 |
| **추적 방식** | STATE.md + phase별 산출물 | PROGRESS.md (SSOT) + 태스크 파일 |
| **사람 개입 모델** | verify 단계에서 pass/fail | Strict 모드의 REVIEW-ESCALATE (3회 실패 시) |
| **초기 러닝 커브** | 슬래시 커맨드 몇 개면 시작 가능 | 프롬프트 7개 + 워크스페이스 구조 이해 필요 |

둘 다 **"긴 컨텍스트를 피하자"** 라는 같은 문제를 풀고 있지만, 접근이 다르다:

- GSD는 "phase 운영 + 문서를 진실의 원천으로" — 워크플로우 자체가 컨텍스트를 정리해준다
- RW는 "서브에이전트로 물리적 격리" — 컨텍스트가 아예 분리되므로 오염 자체가 불가능하다

개인적으로는, Copilot을 주력으로 쓰는 환경이라면 RW 쪽이 과금 구조와 잘 맞는다고 느꼈다.

---

## 마무리

### 이런 분에게 추천한다

- GitHub Copilot을 주력 AI 코딩 도구로 쓰는 개발자
- 한 프롬프트로 최대한 많은 작업을 처리하고 싶은 사람
- 컨텍스트 오염 때문에 대화를 자주 새로 시작하는 경험이 있는 사람
- AI 작업의 추적 가능성(audit trail)이 중요한 프로젝트

### 이런 경우에는 안 맞을 수 있다

- 아주 작은 버그 픽스나 설정 변경 (오버헤드가 큼)
- 실시간으로 대화하면서 코드를 같이 만들어가고 싶은 경우
- Copilot이 아닌 다른 AI 도구를 쓰는 환경 (`runSubagent`는 Copilot 전용)

### 향후 계획

- 다른 프로젝트(이 Astro 블로그 사이트 포함)에도 RW 템플릿을 적용해 볼 예정이다
- Strict 모드의 리뷰어 서브에이전트를 더 정교하게 만들어서, 에스컬레이션 비율을 줄이고 싶다
- 병렬 서브에이전트가 지원되면 활용 방법을 업데이트할 예정이다

"AI가 AI를 관리하는" 이 패러다임이 아직 초기 단계인 건 맞다. 하지만 2\~3일 만에 동작하는 프로젝트 하나를 코드 0줄로 완성했다는 건, 이 방향이 충분히 실용적이라는 증거라고 생각한다.

레포: [copilot-ralph-wiggum-example](https://github.com/jungin-kim/copilot-ralph-wiggum-example)
